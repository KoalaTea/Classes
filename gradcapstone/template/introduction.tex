\section{Introduction}
    The objective of this paper is the development of a security focused continuous integration (CI) pipeline. The goal is to make a pipeline that focuses on security in an attempt to improve web
    application security. This pipeline will automatically run a series of tests against a repository of configuration files and code. These tests will enforce correct configurations and security
    best practices within committed changes.

    CI is a technique that is used to speed up development releases by ensuring code changes do not break the existing code base. Those benefits can also be tailored to improve security in 
    development. Many penetration tests or bug reports revolve around the same information repeated for different cases. These reports often have a common solution. If we discuss web applications, one 
    common vulnerability is cross site scripting (XSS). XSS vulnerabilities have the short term recommendation of encoding all user input to avoid users input being interpreted as part of the webpage. 
    The long term recommendation is to set up a full Content Security Policy (CSP), limiting where scripts and HTML tags can be loaded from. Companies generally choose the short term route of fixing 
    each individual case, but this will cost them too much time and money in the long term, eventually leading them to implement a long term solution. In this example companies will often implement encoding, 
    but as they expand the web application, they find the same bug. The company eventually switches to creating a CSP and configuring it correctly so new expansions can not be affected by a XSS bug.
    
    Everyday applications are getting larger and are handling enormous amounts of data. Many of these applications are services that companies provide, such as Facebook and Netflix. All of these 
    applications need to provide security for both their internal company data and the end user's data. The problem is that as these applications grow, their logic gets more complex and mistakes will 
    be made, potentially introducing vulnerabilities into the codebase without the developers realizing until it is too late. Sometimes these mistakes are simply forgotten flags on cookies and other
    times they can be complex flaws in the business logic of the application. These mistakes can result in damage ranging from defacement of a company site, to a complete breach of a company's 
    internal network.

	A bug does not need to be exploited by a malicious actor to cause financial loss for the company. Many companies offer bug bounty programs, in which a researcher can discover and report a bug 
    for a reward. The rewards vary by company, but often times the researcher will receive a substantial monetary reward, depending on the severity of the bug discovered. This means that each time 
    the company releases updates to their applications, researchers will be scavenging for more vulnerabilities, which can be costly for the company. It may also cost the company's security team a 
    significant amount of time, as they need to look into and verify each report that is submitted. Often times, researchers can find very common vulnerabilities in the application, that usually 
    result from developers rushing to push out new features at such a rapid pace.

	CI can be used to catch simple mistakes automatically, by ensuring that the common bugs are found before the changes are deployed into production. By discovering these bugs before they are introduced 
    into production, the number of submissions from bug bounty programs will decrease dramatically. This is beneficial to the company as it reduces the number of simple submissions, saving the business
    time and money, while the bug reports that are submitted provide more value to the company.

    This paper shows that the development and application of security tests into CI uses the same methods as normal unit testing. The main difference between normal unit testing and security testing
    is that security testing does not focus on the specific functionality of an application, but instead on the testing of generalized security controls. For these tests it is found that dynamic
    tests are more appropriate than static because they can then span accross multiple languages. Further the usefullness of containerization is enforced by how it simplifies dynamic testing in a CI
    pipeline.
